\chapter{Requirements}
\label{chap:requirements}

The group have divided the requirements in three sections: result goals, operational requirements and learning outcomes. Result goals defines what the group expect to deliver as the end product. Operational requirements describe what the team expect from the system after a set amount of time and are listed to give an indication of the intended quality of the final system. Learning outcomes describe what the team wants to learn during development and thesis writing.

\section{Result Goal}
    \begin{itemize}
        \item Program must, at a minimum, be able to abstract and visualize language version up to Java 11.0.2 and C++17.
        \item Code visualization must be in 3D.
        \item Program must give an indication of the quality of the software code.  
        \item Program must be able to take a link to a git repository to use as basis for visualization.
        \item Program must be able to show potential execution paths or program flow through the program.
        \item Program must have a public facing API for developers.
        \item Program must be dockerized. 
        \item The user must be able to interact with the 3D visualization to show implementation of data structures.
        \item The system must present complexity metrics to the user.
        \item The system must give an indication on where complexity arises.
    \end{itemize}
    
\section{Operational requirements}
\newacronym{vcpu}{VCPU}{Virtual Central Processing Unit}
\newacronym{gb}{GB}{GigaByte}
\newacronym{kloc}{KLOC}{Thousands of Lines Of Code}
    The following operational requirements assumes a server equivalent of a \gls{skyhigh} instance of flavor c1.tiny with 16 \gls{gb} of ram, 40 \gls{gb} of disk space and 8 \glspl{vcpu}.  
    \begin{enumerate}  
        \item Quantitative goals for the system: 
        \begin{itemize}
            \item The system must handle 30 concurrent users with repository of less than 10 \gls{kloc} while using less than 10 minutes of processing time.
            \item The system must be able to handle a peak of at least 60 users.
            \item The system must be able to handle repositories of less than 100 \gls{kloc}. 
        \end{itemize}
        \item Qualitative goals for the system:
        \begin{itemize}
            \item The system must help developer(s) gain overview and an understanding of the code base.
            \item The system must let the user easily navigate through the visualization.
            \item The system must be naturally intuitive and easy-to-use for new users.
            \item The system must be accessible to people with minor disabilities, like colorblindness. 
        \end{itemize}
    \end{enumerate}
        
\section{Learning outcome}
    \begin{itemize}
        \item Learn in depths \gls{webgl} technology.
        \item Learn professionalism in web development.
        \item Understand and follow \gls{devops} methodology throughout the project.
        \item Learn in depths dockerizing containers.
        \item Learn \gls{frontend} web frameworks.
        \item Learn about different code quality metrics for static analysis.
        \item Learn about professional web architectures.
        \item Learn about \gls{iac}.
    \end{itemize}

\section{Use Case}
\newglossaryentry{usecase}{name=use case, description={Usually a list of events, often used to describe the interaction between actors and systems}}

To achieve more detailed view of the actual systems functionality that need to be implemented, it is important to visualize the system from users perspective without focusing on implementation details. To do this, \glspl{usecase} and a use-case diagram are used as they show users needs.

\input{inc/figures/usecase.tex}

\subsection{High level use case descriptions}
\noindent\fbox{
    \parbox{\textwidth}{
        \textbf{Use case name:} Change GUI layout                                  \\
        \textbf{Actors:} User                                                        \\
        \textbf{Target:} Target is to change the GUI layout in the application.       \\
        \textbf{Description:} User can change the GUI layout by dragging and scaling windows. User can also add or remove a window of same type or any other type.   
    }
} \\ \\

\noindent\fbox{
    \parbox{\textwidth}{
        \textbf{Use case name:} Add a color-scheme                                 \\
        \textbf{Actors:} User                                                        \\
        \textbf{Target:} Target is to change the color-scheme used in the application. \\
        \textbf{Description:} User can change the color-scheme of application by specifying a set of colors from a palette on the home page.   
    }
} \\ \\


\noindent\fbox{
    \parbox{\textwidth}{
        \textbf{Use case name:} Add a lexer file                                  \\
        \textbf{Actors:} User                                                      \\
        \textbf{Target:} User can add new lexer file to the system.         \\
        \textbf{Description:} User can submit a new lexer files on the home page by clicking on the "upload lexer file" and choosing the file from a remote machine.
    }
} \\ \\

\noindent\fbox{
    \parbox{\textwidth}{
        \textbf{Use case name:} Select quality metrics                              \\
        \textbf{Actors:} User                                                       \\
        \textbf{Target:} User can select a specific quality metric.         \\
        \textbf{Description:} User can choose between different quality metrics such as "connascence measure", "cyclomatic complexity" and "Halstead complexity measures" on the quality metrics window. The chosen metrics will then be used for analysis of the submitted codebase.
    }
} \\ \\

\noindent\fbox{
    \parbox{\textwidth}{
        \textbf{Use case name:} Submit git repository                               \\
        \textbf{Actors:} User                                                         \\
        \textbf{Target:} User can submit the git repository               \\
        \textbf{Description:} User can submit the git repository by adding repository link on the text field with name "Git Repository" and click submit to store repository in the database. The field can be found at home page.
    }
} \\ \\

\noindent\fbox{
    \parbox{\textwidth}{
        \textbf{Use case name:} Load other repository stored in DB                   \\
        \textbf{Actors:} User                                                         \\
        \textbf{Target:} User can load the repositories submitted by other users.     \\
        \textbf{Description:} Database has multiple repositories stored by different users. These repositories will be shown in the window named "Repositories". A user can click on available repositories to visualize it.
    }
} \\ \\

\noindent\fbox{
    \parbox{\textwidth}{
        \textbf{Use case name:} Get implementation of data structure                   \\
        \textbf{Actors:} User                                                         \\
        \textbf{Target:} User can see the implementation of chosen data structure.    \\
        \textbf{Description:} This functionality is required to have at least one entry in the database so that the system can get the representation of codebase. Once the visualization of codebase is shown, user can choose between visualized data structures to see the implementation on a window named "Implementation".
    }
} \\ \\

\noindent\fbox{
    \parbox{\textwidth}{
        \textbf{Use case name:} Navigation of visualization                   \\
        \textbf{Actors:} User                                                         \\
        \textbf{Target:} User can navigate in the 3D environment to see visualized models. \\
        \textbf{Description:} This functionality requires a submitted repository so that the representation of codebase can be shown. The navigation includes rotation, translation and zoom. The user can navigate in 3D environment using mouse or keyboard.
    }
} \\ \\

\noindent\fbox{
    \parbox{\textwidth}{
        \textbf{Use case name:} Highlight connection between data structure          \\
        \textbf{Actors:} User                                                         \\
        \textbf{Target:} Highlighting relations between data structures. \\
        \textbf{Description:} This functionality requires a submitted repository so that the representation of codebase can be shown. Once the codebase is visualized, the user can choose between different data structures visualized to highlight it's links with other data structures. Highlighting connections will brighten the color of all the links and connected data structures, but also dull the color of all the unconnected data structures.
    }
} \\ \\

\noindent\fbox{
    \parbox{\textwidth}{
        \textbf{Use case name:} Get representation of codebase       \\
        \textbf{Actors:} User             \\
        \textbf{Target:} Visualizing the codebase in 3D environment.  \\
        \textbf{Description:} The user starts at the homepage where the git repository to be visualize needs to be submitted. Once the requested git link is submitted and stored in database, user is taken to loading page where user can see the status of processing codebase file from back-end server. After the processing is done user is taken to 3D visualization page where the visualization will show the different data structures represented as a shape and a color. 
    }
} \\ \\
\section{Product backlog}
\begin{table}
    \resizebox{\columnwidth}{!}{
        \csvautotabular{inc/csv/finalIssuelist.csv}
    }
    \caption{Final backlog}
    \label{finalBacklog}
    
\end{table}
The final backlog can be seen in table \ref{finalBacklog}. It show a more detailed view than what is described in the use cases. 

\section{Domain model}
\input{inc/figures/domainModel.tex}
\newglossaryentry{recursion}{name=recursion, description={A computer programming technique involving the use of a procedure, subroutine, function, or algorithm that calls itself one or more times until a specified condition is met at which time the rest of each repetition is processed from the last one called to the first }}
\newglossaryentry{recursive}{name=recursive, description={Of, relating to, or involving \gls{recursion}}}
\newglossaryentry{syntax}{name=syntax, description={The way in which linguistic elements (such as words) are put together to form constituents (such as phrases or clauses)}}

Figure \ref{fig:domainModel} shows a crude overview of the subject area relating to the project. The code structure is language dependent and \gls{recursive} based on the \gls{syntax} rules relating to the structure. The relationship between a call, variable and parameter relates to how a function-call can have parameters that define which overloaded version of a function is being called. This relationship is given as an example but there are many other similar relationships that have not been added for clarity, like how variable types such as classes can define the scope a function is being called from. This is a relationship between functions being defined as part of a class, variables being instances of said class and calls being called on said variable.

\Gls{syntax} rules are also \gls{recursive} as they can be defined by a set of rules or a character sequence.

\section{Risk assessment}
The initial task description and product owner did not give any specific security requirements and has therefore done a risk assessment to identify any shortcomings that might happen and how to deal with them. This risk assessment will be a part of the base for the security requirements.

\subsection{Identification and project risk analysis}
\newglossaryentry{manhattanDistance}{name={manhattan distance}, description={The distance between two points measured along axes at right angles \cite{manhattanDistance}}}
The table \ref{riskOverview} contains possible risks based on \cite{DBLP:journals/corr/abs-1708-02174} and compared with the system requirements. The probabilities and effects are estimates done by the core team. The priority is based on the minimal \gls{manhattanDistance} from top right corner of table \ref{riskForm}.

\input{inc/tables/RiskOverview.tex}

\input{inc/tables/RiskAnalysis.tex}

\subsection{Risk mitigation strategy}

Table \ref{riskMitigation} shows the mitigation strategy for the project risks with highest priority and should give an overview of mitigations that should help with most of the identified risks, as several can be mitigated with similar strategies.

\input{inc/tables/RiskMitigation.tex}

\newglossaryentry{git}{name=Git, description={Version control system}}
\newglossaryentry{dosAttack}{name=DOS-attack, description={Denial of Service attack}}
\newglossaryentry{proprietary}{name=proprietary, description={Closed source}}
\newglossaryentry{xssAttack}{name=XSS-attack, description={Cross site scripting, input executable code that will run on other instances of the service}}
\newglossaryentry{sql}{name=SQL, description={Structured Query Language used for Querying from certain database systems}}
\newglossaryentry{sqliAttack}{name=SQLi-attack, description={\gls{sql} injection, input of executable \gls{sql} code that could modify a \gls{sql}-based database system}}

\section{Security requirements}
\begin{itemize}
    \item Sanitization of input from external sources within visualization and field for repository link submission to mitigate \gls{sqliAttack} and \gls{xssAttack}s.
    \item The application will not in any way record or process any data that can be used to identify usage patterns for individual or corporation. 
    \item Application will not store nor expose sensitive personal or corporate project information.
    \item The submitted repositories that are stored, are only stored for visualization of the codebase and will not at any point be built by the application.
    \item Any submitted repository will not be used for any other purpose than for visualization and quality assessment.
    \item Extensive testing to mitigate instabilities.
\end{itemize}